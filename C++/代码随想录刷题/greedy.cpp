//****************************************
// 贪心算法
// Created by DSC，2025/1/26
//****************************************
#include"head.h"


// 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。
// 比如有一堆钞票，只能拿 5 张，怎样使金额最大？
// 肯定是每次拿金额最大的钞票，最后拿到的五张钞票金额就最大，  
// 每次拿最大金额的就是局部最优解，最后最大的金额就是全局最优解

// 和动态规划的区别：
// 举一个例子： 有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，
// 如果还每次选最大的盒子，就不行了。这时候就需要动态规划。
// 动态规划的下一个状态可以由上一个或多个状态推导出来，

// 贪心类型的题目没有固定套路，难点就是由局部最优得到全局最优。
// 一般就是手动模拟，可以使用贪心就使用。

// 1、分发饼干
// 题目：
// 每个孩子最多只能给一块饼干。
// 对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；
// 并且每块饼干 j，都有一个尺寸 s[j] 。
// 如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。
// 你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

// 示例  1:
// 输入: g = [1, 2, 3], s = [1, 1]
// 输出 : 1 解释 : 你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1, 2, 3。
// 虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。

// 示例  2 :
// 输入 : g = [1, 2], s = [1, 2, 3]
// 输出 : 2
// 解释 : 你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1, 2。
// 你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2.

// 解题思路：
// 为了满足更多的小孩，就不要造成饼干尺寸的浪费。
// 大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。
// 局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。
// 可以尝试使用贪心策略，先将饼干数组和小孩数组排序。
// 然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。

class greedy1
{
public:
	int findContentChildren(vector<int>& cookies, vector<int>& childs)
	{
		sort(cookies.begin(), cookies.end());
		sort(childs.begin(), childs.end());
		int result = 0;
		int cookieIndex = cookies.size() - 1;
		for (int i = childs.size() - 1; i >= 0; --i)
		{
			if (cookieIndex >= 0 && cookies[cookieIndex] >= childs[i])
			{
				++result;
				--cookieIndex;
			}
		}
		return result;
	}
};

// 2、摆动序列
//如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。
//第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
//
//例如，[1, 7, 4, 9, 2, 5] 是一个摆动序列，因为差值(6, -3, 5, -7, 3)  是正负交替出现的。
//相反, [1, 4, 7, 2, 5]  和[1, 7, 4, 5, 5] 不是摆动序列，
//第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
//
//给定一个整数序列，返回作为摆动序列的最长子序列的长度。 
//通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

// 解法 1：贪心解法
// 删除单调坡度上的结点，有如下情况：
// (1) 上下坡中有平坡，比如 1，2,2,2,2,1 ，需要删除其中的任意三个 2
// (2) 数组首尾两端，比如 2,2,5，或 2,5,5，
// (3) 单调坡度有平坡，比如 1,2,2,2，3,4


// 不去管什么条件下不满足，只记录满足条件的
class greedy2 {
public:
	int wiggleMaxLength(vector<int>& nums) 
	{
		if (nums.size() <= 1) return nums.size();
		int curDiff = 0; // 当前一对差值
		int preDiff = 0; // 前一对差值
		int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
		for (int i = 0; i < nums.size() - 1; i++) 
		{
			curDiff = nums[i + 1] - nums[i];
			
			// 出现峰值，注意 <=0 和 >=0 对应的边界情况
			if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) 
			{
				++result; // 满足条件就将峰值加一
				preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff
			}
		}
		return result;
	}
};

// 3、最大子序列和
// 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

// 示例 :
// 输入: [-2, 1, -3, 4, -1, 2, 1, -5, 4]
// 输出 : 6
// 解释 : 连续子数组[4, -1, 2, 1] 的和最大，为  6。

// 解题思路：
//如果 -2，1 在一起，计算起点的时候，一定是从 1 开始计算，因为负数只会拉低总和，这就是贪心贪的地方！
//
//局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，
//因为负数加上下一个元素 “连续和”只会越来越小。
//
//全局最优：选取最大“连续和”
//
//局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。

//从代码角度上来讲：遍历 nums，从头开始用 count 累积，如果 count 一旦加上 nums[i]变为负数，
//那么就应该从 nums[i + 1]开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和。

class greedy3
{
public:
	int maxSubArray(vector<int>& nums)
	{
		// 注意 result 为什么要初始化为最小的负整数，
		// 用于存储当前找到的最大子数组和，初始值为 INT32_MIN（最小的 32 位负整数），
		// 确保任何有效的子数组和都会比它大。
		int result = INT32_MIN; 
		int count = 0;
		for (int i = 0; i < nums.size(); ++i)
		{
			count += nums[i];

			// 取区间累计的最大值（相当于不断确定最大子序终止位置）
			if (count > result)result = count;

			// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
			if (count <= 0)count = 0;
		}
		return result;
	}
};

// 4、买卖股票的最大利润
//给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。
//设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
//注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
//
//示例 1:
//输入: [7, 1, 5, 3, 6, 4]
//输出 : 7
//解释 : 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 
//这笔交易所能获得利润 = 5 - 1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，
//在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。

// 解题思路：很容易想到不断地在低点买入，在高点卖出就能获得利润

// 最关键的点是，利润其实是可以分解的，比如下面的分析：
// 假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。
// 相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。
// 此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！
//那么根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1]).....(prices[1] - prices[0])。

// 比如股票价格为 [7,1,5,10,3,6,4]，那么每天的利润为 [-6,4,5,-7,3,-2]
// 注意，利润只从第二天才开始有，第一天不会产生利润，所以利润数量比股票数量少 1
// 收集其中的正利润就行
class greedy4
{
public:
	int maxProfit(vector<int>& prices)
	{
		int result = 0;
		for (int i = 1; i < prices.size(); ++i)
			result += max(prices[i] - prices[i - 1], 0);
		return result;
	}
};

// 5、跳跃游戏
/*
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。

示例  1:
输入: [2, 3, 1, 1, 4]
输出 : true
解释 : 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

示例  2 :
输入 : [3, 2, 1, 0, 4]
输出 : false
解释 : 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ，
所以你永远不可能到达最后一个位置。
*/

// 解题思路：
// 在当前位置，其实跳几步无所谓，关键在于可跳的覆盖范围！
// 不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。
// 这个范围内，别管是怎么跳的，反正一定可以跳过来。

// 那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！
// 每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。
// 贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），
// 整体最优解：最后得到整体最大覆盖范围，看是否能到终点。
class greedy5
{
public:
	bool jumpGame(vector<int>& nums)
	{
		if (nums.size() == 1)return true;
		int cover = 0;
		for (int i = 0; i <= cover; ++i) // 注意是 <=cover
		{
			cover = max(i + nums[i], cover);
			if (cover >= nums.size() - 1)return true; // 下标从 0 开始，所以是 nums.size() - 1
		}
		return false;
	}
};

// 6、跳跃游戏2
/*
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳  1  步，然后跳  3  步到达数组的最后一个位置。
说明: 假设你总是可以到达数组的最后一个位置。
*/

// 解题思路：
/*
贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。
整体最优：一步尽可能多走，从而达到最少步数。

思路虽然是这样，但在写代码的时候还不能真的能跳多远就跳多远，那样就不知道下一步最远能跳到哪里了。

所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，
以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！

这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。

如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，
那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。
*/
class greedy6
{
public:
	int minJumpStep(vector<int>& nums)
	{
		if (nums.size() == 1)return 0;
		int curDistance = 0; // 当前覆盖最远距离的下标
		int nextDistance = 0; // 下一步覆盖最远距离的下标
		int ans = 0; // 记录走的最大步数
		for (int i = 0; i < nums.size(); ++i)
		{
			// 更新下一步覆盖最远距离下标
			nextDistance = max(nums[i] + i, nextDistance);
			if (i == curDistance) // 遇到当前覆盖最远距离下标
			{
				++ans; // 需要再走一步才能到达末尾
				curDistance = nextDistance; // 更新当前覆盖最远距离下标
				
				// 当前覆盖最远距离能到达集合终点，就不用再走下一步了，直接结束
				if (nextDistance >= nums.size() - 1)break;
			}
		}
		return ans;
	}
};

// 7、K 次取反后最大化的数组和
/*
给定一个整数数组 A，我们只能用以下方法修改该数组：
我们选择某个索引 i 并将 A[i] 替换为 - A[i]，然后总共重复这个过程 K 次。
（我们可以多次选择同一个索引 i。）
以这种方式修改数组后，返回数组可能的最大和。

示例 1：
输入：A = [4, 2, 3], K = 1
输出：5
解释：选择索引(1) ，然后 A 变为[4, -2, 3]。

示例 2：
输入：A = [3, -1, 0, 2], K = 3
输出：6
解释：选择索引(1, 2, 2) ，然后 A 变为[3, 1, 0, 2]。

示例 3：
输入：A = [2, -3, -1, 5, -4], K = 2
输出：13
解释：选择索引(1, 4) ，然后 A 变为[2, 3, -1, 5, 4]。
*/

class greedy7
{
	// 返回绝对值大的
	static bool absGreater(int a, int b)
	{
		return abs(a) > abs(b);
	}
public:
	int KReverseMaxSum(vector<int>& nums,int k)
	{
		// 按绝对值从大到小排序
		sort(nums.begin(), nums.end(), absGreater);

		// 遍历，将负数变为正数，直到 k 变为 0
		for (auto& val : nums) // 这种 for 循环方式要修改 val 的值需要使用引用
		{
			if (val < 0 && k>0)
			{
				val *= -1;
				--k;
			}
		}

		// 遍历完之后 k 仍然大于 0，如果是偶数的话，取反偶数次相当于没有处理
		// 取反奇数次相当于取反一次，所以只看奇数次即可
		// 将绝对值最小的取反，保证得到的是最大和
		if (k % 2 == 1)nums[nums.size() - 1] *= -1;
		
		// 求处理完后的和
		int result = 0;
		for (auto val : nums)result += val;
		return result;
	}
};

// 8、加油站
/*
在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i + 1 个加油站需要消耗汽油 cost[i] 升。
你从其中的一个加油站出发，开始时油箱为空。
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 - 1。

说明 :
如果题目有解，该答案即为唯一答案。
输入数组均为非空数组，且长度相同。
输入数组中的元素均为非负数。

示例 1 : 输入 :
	gas = [1, 2, 3, 4, 5]
	cost = [3, 4, 5, 1, 2]
	输出 : 3 解释 :

	从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
	开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
	开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
	开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
	开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
	开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
	因此，3 可为起始索引。
*/

// 解法一：贪心算法
/*
首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，
说明 各个站点的加油站 剩油量 rest[i] 相加一定是大于等于零的。

每个加油站的剩余量 rest[i] 为 gas[i] - cost[i]。

i 从 0 开始累加 rest[i]，和记为 curSum，一旦 curSum 小于零，
说明 [0, i] 区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，
那么起始位置从 i + 1 算起，再从 0 计算 curSum。
*/

class greedy8
{
public:
	int canCompleteCircuit(vector<int>& gas, vector<int>& cost)
	{
		int curSum = 0;
		int totalSum = 0;
		int start = 0;
		for (int i = 0; i < gas.size(); ++i)
		{
			curSum += gas[i] - cost[i]; // 当前累加和
			totalSum += gas[i] - cost[i]; // 总的累加和
			if (curSum < 0) // 当前累加和 curSum 一旦小于 0
			{
				start = i + 1; // 起始位置更新为 i+1
				curSum = 0; // 当前累加和置 0 
			}
		}
		if (totalSum < 0)return -1; // 说明怎么走都走不了一圈
		return start;
	}
};

// 9、分发糖果
/*
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。
相邻的孩子中，评分高的孩子必须获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

示例 1:
输入: [1, 0, 2]
输出 : 5
解释 : 你可以分别给这三个孩子分发 2、1、2 颗糖果。

示例 2 :
输入 : [1, 2, 2]
输出 : 4
解释 : 你可以分别给这三个孩子分发 1、2、1 颗糖果。
第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
*/

// 解题思路：
// 先初始化一个大小为学生数且全为 1 的数组，然后再分别实现从前往后遍历和从后往前遍历
// 从前往后遍历，如果右边的比左边的表现好，那么其糖果就比左边的多 1
// 从后往前遍历，如果左边的比右边的表现好，那么其糖果就比右边的多 1 

class greedy9
{
public:
	int minSugar(vector<int>& rates)
	{
		vector<int>sugar(rates.size(), 1); // 存放糖果数，初始值全为 1 
		
		// 从左向右。注意开始的顺序是 1 ，不是 0
		for (int i = 1; i < rates.size(); ++i)
		{
			// 相邻的，如果右边表现比左边好，糖果就比左边多一颗
			if (rates[i] > rates[i - 1])sugar[i] = sugar[i - 1] + 1;
		}

		// 从右向左。注意 i 开始的顺序
		for (int i = rates.size() - 2; i >= 0; --i)
		{
			// 注意此时糖果的取值
			if (rates[i] > rates[i + 1])sugar[i] = max(sugar[i], sugar[i + 1] + 1);
		}

		int result = 0;
		for (auto val : sugar)
			result += val;
		return result;
	}
};

// 10、找零
/*
在柠檬水摊上，每一杯柠檬水的售价为 5 美元。
顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。
每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。
你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。
如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

示例 1：
输入：[5, 5, 5, 10, 20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。

示例 2：
输入：[5, 5, 10]
输出：true

示例 3：
输入：[10, 10]
输出：false
*/

// 解题思路：
// 由于最开始手里没有零钱，所以第一张不是 5 就不能找零，直接返回 false
// 创建三个变量记录三种钱的数量，初始值都是 0。然后遍历所给的数组，分情况讨论：
// (1) 5 美元。5 美元的数量就加一，用于后面找零
// (2) 10 美元。10 美元的数量加一，可用于给 20 美元找零，
// 因为要找零，所以 5 美元的数量减一。
// (3) 20 美元。不用增加 20 美元的数量，因为不用 20 美元找零。
// 20 美元找零又有 10+5 和 5+5+5 两种方式，优先使用 10+5 ，因为 5 的作用更大，
// 还可以用来给 10 美元找零，这里就是贪心表现的地方。

class greedy10
{
public:
	bool finMoney(vector<int>& money)
	{
		// 剪枝
		if (money[0] != 5)return false;
		
		// 创建三个变量记录对应美元的数量
		int fiveCount = 0;
		int tenCount = 0;
		int twentyCount = 0;
		for (auto mon : money) // 遍历
		{
			// 遇到 5，将数量加一，不作其它操作
			if (mon == 5)++fiveCount;
			if (mon == 10)
			{
				// 遇到 10，如果没有 5 美元，就不能找零
				if (fiveCount <= 0)return false;
				++tenCount;
				--fiveCount;
			}
			if (mon == 20)
			{
				// 以 10+5 找零
				if (tenCount > 0 && fiveCount > 0)
				{
					--tenCount;
					--fiveCount;
					++twentyCount; // 可以删除，因为不用 20 找零
				}
				else if (fiveCount >= 3) // 以 5+5+5 找零
				{
					fiveCount -= 3;
					++twentyCount;// 同上，也可以删除
				}
				else return false;
			}
		}
		return true;
	}
};

// 11、未完结，