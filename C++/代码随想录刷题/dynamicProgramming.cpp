//*******************************************
// 动态规划
// created by DSC ，2025/1/29
//*******************************************

/*
动态规划，英文：Dynamic Programming，简称 DP，
如果某一问题有很多重叠子问题，使用动态规划是最有效的。
所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，
贪心没有状态推导，而是从局部直接选最优的，
*/

// 动态规划解题步骤，归纳为五部曲：
// (1)确定 dp 数组（dp table）以及下标的含义
// (2)确定递推公式
// (3) dp 数组如何初始化
// (4)确定遍历顺序
// (5)举例推导 dp 数组
// 要先确定递推公式，再考虑初始化，因为一些情况是递推公式决定了 dp 数组要如何初始化！

#include"head.h"

// 1、斐波那契数列
/*
斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。
该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。
也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。

示例 1：
输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1

示例 2：
输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2

示例 3：
输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
*/

// 解题步骤，按照五部曲一一确定
// (1) 确定数组及下标的含义。dp[i] 的定义为：第 i 个数的斐波那契数值是 dp[i]
// (2) 确定递推公式。状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];
// (3) 初始化。dp[0]=0,dp[1]=1
// (4) 确定遍历顺序。dp[i]依赖 dp[i - 1] 和 dp[i - 2]，遍历顺序一定是从前到后
// (5) 举例推导 dp 数组。
// 比如求 dp[10],应该是：0 1 1 2 3 5 8 13 21 34 55，打印结果看是否一致。

class dynamic1
{
public:
	// 解法 1：维护整个数组
	int fib1(int N)
	{
		if (N<=1)return N;

		// 注意，斐波那契数列下标从 0 开始，也就是传入的 N 可以为 0，
		// 所以数组的大小就比传入的 N 要大一。
		vector<int>dp(N + 1);
		dp[0] = 0; // 初始化第一个值
		dp[1] = 1; // 初始化第二个值
		for (int i = 2; i <= N; ++i) // 从第三个值开始
		{
			dp[i] = dp[i - 1] + dp[i - 2];
		}
		return dp[N]; // 返回数列的第 n 个值，当然 N 从 0 开始
	}
	
	// 解法 2：只需要维护 dp[0] 和 dp[1] 即可，
	int fib2(int n)
	{
		if (n <= 1)return n;
		int dp[2];
		dp[0] = 0;
		dp[1] = 1;
		for (int i = 2; i <= n; ++i)
		{
			int temp = dp[0] + dp[1]; // 用于更新 dp[1]
			dp[0] = dp[1];
			dp[1] = temp;
		}
		return dp[1];
	}
};

// 2、爬楼梯。实质上就是斐波那契数列
/*
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。

示例 1：
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1 阶 + 1 阶
2 阶

示例 2：
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1 阶 + 1 阶 + 1 阶
1 阶 + 2 阶
2 阶 + 1 阶
*/

// 解题思路：
// 爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。
// 那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。
// 所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，就可以想到动态规划。

// 五部曲
// (1)确定 dp[i] 的含义。 这里表示爬到第 i 层楼梯，有 dp[i] 种方法
// (2)递推公式。dp[i]=dp[i-1]+dp[i-2]
// (3)初始化。重点是 dp[0] 的初始化，由于题目说 n 是正整数，
// 所以直接考虑初始化 dp[1] 和 dp[2]，然后从 dp[3] 开始递推。
// 实在要初始化 dp[0] 的话，初始化为 0 或 1 都行。
class dynamic2
{
public:
	// 解法 1：维护整个数组
	int climbStairs1(int n)
	{
		if (n <= 1)return n;
		vector<int>dp(n + 1);
		dp[1] = 1;
		dp[2] = 2;
		for (int i = 3; i <= n; ++i)
		{
			dp[i] = dp[i - 1] + dp[i - 2];
		}
		return dp[n];
	}
	
	// 解法 2：只需要维护 dp[1] 和 dp[2]，优化空间复杂度
	int climbStairs2(int n)
	{
		if (n <= 1)return n;
		int dp[3];
		dp[1] = 1;
		dp[2] = 2;
		for (int i = 3; i <= n; ++i)
		{
			int temp = dp[1] + dp[2];
			dp[1] = dp[2];
			dp[2] = temp;
		}
		return dp[2];
	}
};

// 3、爬楼梯的最少花费
/*
数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。
每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，
你就可以选择向上爬一个阶梯或者爬两个阶梯。
请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。
注意，过了最后一个台阶之后才是楼顶

示例 1：
输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。

示例 2：
输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出：6
解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。

题目中说 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯” ，
也就是相当于 跳到 下标 0 或者 下标 1 是不花费体力的，从 下标 0 或 下标1 开始跳就要花费体力了
*/

// 解题思路：
// (1)确定 dp[i] 的含义。到达第 i 台阶所花费的最少体力为 dp[i] 。
// (2)确定递推公式。
// 可以有两个途径得到 dp[i] ，一个是 dp[i - 1] 一个是 dp[i - 2]。
// dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。
// dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。
// 那么究竟是选从 dp[i - 1] 跳还是从 dp[i - 2] 跳呢？
// 一定是选最小的，所以 dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
// (3) 初始化。
// 题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 
// 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。
// 所以初始化 dp[0] = 0，dp[1] = 0;
// (4)确定遍历顺序。
// 因为是模拟台阶，而且 dp[i] 由 dp[i-1] 和 dp[i-2] 推出，所以是从前到后遍历。
// (5)举例推导。比如 cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 
// 那么 dp=[0,0,1,2,2,3,3,4,4,5,6]

class dynamic3
{
public:
	// 解法 1，维护整个数组
	int minCost1(vector<int>& cost)
	{
		vector<int>dp(cost.size() + 1);
		dp[0] = 0;
		dp[1] = 0;
		for (int i = 2; i <= cost.size(); ++i)
		{
			dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
		}
		return dp[cost.size()];
	}
	
	// 解法 2：仅维护 dp[0] 和 dp[1] 即可
	int minCost2(vector<int>& cost)
	{
		int dp[2];
		dp[0] = 0;
		dp[1] = 0;
		for (int i = 2; i <= cost.size(); ++i)
		{
			int temp = min(dp[0] + cost[i - 2], dp[1] + cost[i - 1]);
			dp[0] = dp[1];
			dp[1] = temp;
		}
		return dp[1];
	}
};

// 4、二维矩阵中的不同到达路径
// 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
// 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
// 问总共有多少条不同的路径？

// 解题思路 1：二叉树
// 这道题目，刚一看最直观的想法就是用图论里的深搜，来枚举出来有多少种路径。
// 注意题目中说机器人每次只能向下或者向右移动一步，
// 那么其实机器人走过的路径可以抽象为一棵二叉树，而叶子节点就是终点！
// 此时问题就可以转化为求二叉树叶子节点的个数，代码如下：
/*
class dynamic4 {
private:
	int dfs(int i, int j, int m, int n) {
		if (i > m || j > n) return 0; // 越界了
		if (i == m && j == n) return 1; // 找到一种方法，相当于找到了叶子节点
		return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);
	}
public:
	int uniquePaths(int m, int n) {
		return dfs(1, 1, m, n);
	}
};
*/
// 但是该方法要遍历整棵二叉树，时间复杂度是指数级别。

// 解题思路 2：动态规划
// 动态规划五部曲：
// (1) dp[i][j] 的含义。表示从（0 ，0）出发，到(i, j) 有 dp[i][j] 条不同的路径。
// (2) 确定递推公式。想要求 dp[i][j]，只能从两个方向：dp[i-1][j] 和 dp[i][j-1]。
// 而 dp[i-1][j] 表示从 (0,0)到(i-1,j) 有多少条路径，dp[i][j-1] 表示从 (0,0)到(i,j-1) 有多少条路径
// 所以递推公式为： dp[i][j] = dp[i-1][j] + dp[i][j-1]
// (3) dp 数组的初始化。
// 到达第一行和第一列都只有一条路径，所以 dp[i][0] = 1，dp[0][i] = 1,
// (4) 确定遍历顺序。
// 根据递推公式，dp[i][j] 都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。
// 这样就可以保证推导 dp[i][j] 的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。

class dynamic4
{
public:
	// 解法 1：维护整个数组
	int allPaths1(int row, int col)
	{
		// 创建一个二维数组
		vector<vector<int>>dp(row, vector<int>(col, 0));
		
		// 初始化第一行和第一列为 1
		for (int i = 0; i < col; ++i)dp[0][i] = 1;
		for (int i = 0; i < row; ++i)dp[i][0] = 1;

		// 从第二行的第二列开始遍历
		for (int i = 1; i < row; ++i)
		{
			for (int j = 1; j < col; ++j)
				dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // 递推公式
		}
		return dp[row - 1][col - 1];
	}
	
	// 解法 2：一维数组，相当于滚动数组，没理解。
	int allPaths2(int row, int column)
	{
		vector<int> dp(column);
		for (int i = 0; i < column; ++i) dp[i] = 1;
		for (int j = 1; j < row; ++j) 
		{
			for (int i = 1; i < column; ++i) 
			{
				dp[i] += dp[i - 1];
			}
		}
		return dp[column - 1];
	}
};

// 5、求所有路径，但是有些地方有障碍。
// 图中可以走的地方为 0 ，障碍为 1
class dynamic5
{
public:
	int allPathsWithObstacle(vector<vector<int>>& obstacleGrid)
	{
		int m = obstacleGrid.size(); // 获取所给矩阵的行数
		int n = obstacleGrid[0].size(); // 列数

		// 障碍在首或尾，都不能到达终点（右下角）
		if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1)
			return 0;

		// 创建一个和所给矩阵一样大的二维矩阵 dp ，并初始化为 0 ，记录到达位置 [i][j] 的路径数 
		vector<vector<int>>dp(m, vector<int>(n, 0));
		
		// 初始化 dp 矩阵。前面我们知道，如果没有障碍，那么到达第一行和第一列的路径都只有一条
		// 将 dp 矩阵的第一行和第一列全部初始化为 1 即可。但如果第一行或第一列有障碍，
		// 那么障碍及障碍之后就不能到达，仍然是 0 。
		for (int i = 0; i < m && obstacleGrid[i][0] == 0; ++i) // 第一列
			dp[i][0] = 1;
		for (int i = 0; i < n && obstacleGrid[0][i] == 0; ++i) // 第一行
			dp[0][i] = 1;

		// 从第二行第二列开始遍历
		for (int i = 1; i < m; ++i)
		{
			for (int j = 1; j < n; ++j)
			{
				if (obstacleGrid[i][j] == 1)continue; // 碰到障碍直接跳出循环
				dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // 递推公式
			}
		}
		return dp[m - 1][n - 1];
	}
};

// 6、整数拆分。没懂
// 给定一个正整数 n，将其拆分为 至少两个 正整数的和，并使这些整数的乘积最大化。
// 返回你可以获得的最大乘积。

// 示例 1:
//	输入: 2
//	输出 : 1
//	解释 : 2 = 1 + 1, 1 × 1 = 1。
//
// 示例 2 :
//	输入 : 10
//	输出 : 36
//	解释 : 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
//	说明 : 你可以假设 n 不小于 2 且不大于 58。

// 动态规划五部曲：
// (1)确定 dp 数组以及下标的含义 dp[i]：分拆数字 i，可以得到的最大乘积为 dp[i]。
// (2)递推公式。第一种：j * (i-j) 。第二种：j * dp[i - j]，相当于是拆分(i - j)
//    为什么不拆分 j，因为 j 是从 1 开始遍历，拆分 j 的情况，在遍历 j 的过程中其实都计算过了。
//    从 1 遍历 j，比较(i - j)* j 和 dp[i - j] * j 取最大的。
//    递推公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
//    也可以这么理解，j* (i - j) 是单纯的把整数拆分为两个数相乘，
//    而 j* dp[i - j] 是拆分成两个以及两个以上的个数相乘。
//    如果定义 dp[i - j] * dp[j] 也是默认将一个数强制拆成 4 份以及 4 份以上了。
//    那么在取最大值的时候，为什么还要比较 dp[i] 呢？
//    因为在递推公式推导的过程中，每次计算 dp[i]，取最大的而已。
// (3)初始化。
// 严格从 dp[i] 的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。
// 拆分 0 和拆分 1 的最大乘积是多少？这是无解的。
// 只初始化 dp[2] = 1，从 dp[i] 的定义来说，拆分数字 2，得到的最大乘积是 1，没有异议！
// (4)确定遍历顺序
// dp[i] 是依靠 dp[i - j] 的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。

// 因为拆分一个数 n 使之乘积最大，那么一定是拆分成 m 个近似相同的子数相乘才是最大的。
// 例如 6 拆成 3 * 3， 10 拆成 3 * 3 * 4。 100 的话 也是拆成 m 个近似数组的子数 相乘才是最大的。
// 只不过我们不知道 m 究竟是多少而已，但可以明确的是 m 一定大于等于 2，
// 既然 m 大于等于 2，也就是 最差也应该是拆成两个相同的 可能是最大值。
// 那么 j 遍历，只需要遍历到 n / 2 就可以，后面就没有必要遍历了，一定不是最大值。
class dynamic6 
{
public:
	int integerBreak(int n) 
	{
		vector<int> dp(n + 1);
		dp[2] = 1;
		for (int i = 3; i <= n; i++) 
		{
			for (int j = 1; j <= i / 2; j++) 
			{
				dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
			}
		}
		return dp[n];
	}
};

// 没懂
// 7、给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

class dynamic7 
{
public:
	int numTrees(int n) {
		vector<int> dp(n + 1);
		dp[0] = 1;
		for (int i = 1; i <= n; i++) 
		{
			for (int j = 1; j <= i; j++) 
			{
				dp[i] += dp[j - 1] * dp[i - j];
			}
		}
		return dp[n];
	}
};


// 没有完全理解
// 背包问题，只需要掌握 01 背包 和 完全背包 即可

// 8、01 背包
// 有 n 件物品和一个最多能背重量为 w 的背包。
// 第 i 件物品的重量是 weight[i]，得到的价值是 value[i] 。
// 每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

// 方法：使用二维矩阵 dp[i][j]，横坐标表示背包容量，纵坐标表示物品，
// dp[i][j] 表示从下标为 [0-i] 的物品里任意取，放进容量为 j 的背包，价值总和最大是多少。

class dynamic8
{
public:
	int bao() 
	{
		int n, bagweight;// bagweight代表行李箱空间

		cin >> n >> bagweight;

		vector<int> weight(n, 0); // 存储每件物品所占空间
		vector<int> value(n, 0);  // 存储每件物品价值

		for (int i = 0; i < n; ++i) {
			cin >> weight[i];
		}
		for (int j = 0; j < n; ++j) {
			cin >> value[j];
		}
		// dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值
		vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

		// 初始化, 因为需要用到dp[i - 1]的值
		// j < weight[0]已在上方被初始化为0
		// j >= weight[0]的值就初始化为value[0]
		for (int j = weight[0]; j <= bagweight; j++) {
			dp[0][j] = value[0];
		}

		for (int i = 1; i < weight.size(); i++) { // 遍历科研物品
			for (int j = 0; j <= bagweight; j++) { // 遍历行李箱容量
				if (j < weight[i]) dp[i][j] = dp[i - 1][j]; // 如果装不下这个物品,那么就继承dp[i - 1][j]的值
				else {
					dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
				}
			}
		}
		cout << dp[n - 1][bagweight] << endl;
	}
};

